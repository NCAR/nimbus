#!/usr/bin/perl
use strict;
print "\n";
#flags and defults
our $ext = "jpg";
our $speedhack = 0;
our $verbose = 0;
our $force = 0;
our $dir = "";
our $checkDark = 1;
our $checkGnd = 1;
#Ajusting these values will change what images the script removes (higher values = more bright)
our @threshold;
$threshold[0] = 50; #if Mean is low image is dark
$threshold[1] = 35; #if Standard Deviation is low image is mostly one color
our $project = -1;
our $flight = -1;

if (@ARGV <= 0) {
	print<<EOF;
	NO COMMAND LINE ARGUMENTS ENTERED
	This script will search through an image directory and removes very dark images using imagemagick also removes images taken on the ground using flt_time script (Installed on Merlot).
	Usage:	./Image_Filter.pl [OPTIONS] TARGET_DIR

	Options:
		-ext:jpg	Sets file extention (Default: jpg)
		-maxmean:##	Sets maximum average pixel value (per color) (Default:50) {0-255}
		-maxstddev:##	Sets maximum pixel value standard deviation (per color) (Default:35) {0-255}
		-proj:PLOWS	Sets project [NOT YET IMPLEMENTED]
		-gndonly	Skips dark image check/removal and removed only ground images (based on flt_time script) [NOT YET IMPLEMENTED]
		-darkonly	Skips ground image check/removal [NOT YET IMPLEMENTED]
		-v		Verbose (prints file operations)
		-f		Force (Skips confimation and does not display list of dark images)
		-r		PERMANATLY REMOVE (normally dark images are moded to target_DIR/removed/) [NOT YET IMPLEMENTED]
		-tdir:removed	Sets name of subdir that dark images are moved to (Default: removed) [NOT YET IMPLEMENTED]
		-s:##		File skipping, Checks every ## files and assumes the images inbetween based on the images checked (Default: 0) {0-inf}
		-s%:##		Sets file skipping to a percentage of total files (Default: NA) {0-100} [NOT YET IMPLEMENTED]
EOF
	die "";	
}
else {
	#Process command line arguments
	foreach my $a (@ARGV) {
		if ($a =~ m/-ext:(\S*)/) {$ext = $1;}
		elsif ($a =~ m/-maxmean:(\d+)/) { $threshold[0] = $1; }
		elsif ($a =~ m/-maxstddev:(\d+)/) { $threshold[1] = $1; }
		elsif ($a =~ m/-proj:(.*)/) {} #NOT IMPLEMENTED
		elsif ($a eq m/-gndonly/) {} #NOT IMPLEMENTED
		elsif ($a eq m/-darkonly/) {} #NOT IMPLEMENTED
		elsif ($a eq "-v") {$verbose = 1;}	
		elsif ($a eq "-f") {$force = 1;}
		elsif ($a eq "-r") { } #NOT IMPLEMENTED 
		elsif ($a =~ m/-tdir:(.*)/) {} #NOT IMPLEMENTED
		elsif ($a =~ m/-s:(\d+)/) {$speedhack = $1; }
		elsif ($a =~ m/-s%:(\d+)/) {} #NOT IMPLEMENTED
		elsif (-d $a) {$dir = $a;} #target dir
		elsif ($a eq "" || $a eq "\n") {} #For capturing stangeness
		else {die "INVALID ARGUMENT: $a";}	
	}
	if ($dir eq "") {die "NO DIRECTORY ENTERED: $dir";}
}

print "Reading directory: $dir\n";
opendir(DIR, "$dir");
my @files = readdir(DIR);
close(DIR);

#Sort files, this allows the script to skip files and accuratly assume what the files skipped contain
if ($speedhack || $checkGnd) { print "Sorting Files\n"; @files = sort { lc($a) cmp lc($b) } @files; }

if ($project == -1) {
	$dir =~ m/\/Raw_Data\/(.*)\//;
	$project = $1;
}
if ($flight == -1) {
	$dir =~ m/camera_images\/flight_number_(\S\S\d\d)/;
	$flight = $1;
}
if (-e "/scr/raf/Prod_Data/$1/$1$2.nc") {
	print "YAY I rock at regular expressions!\n" and die "been fun\n"; 
}
else {
	print "Could not find netCDF file, skipping ground image removal.\n";
}



#dark checking variable declarations
my $speeddark = 0; #this will be set to 1 if a dark file is encountered
my @speedHist; #list of files skipped in the last iteration
my @filesToRemove; #list of files idetified as dark
my $count = 0;

print "Scanning for dark images: 0% Done";
foreach my $file (@files) {
	$count++;
	if ($count % int(($#files+1)/20)  == 0) { print "\rScanning for dark images: " . int($count/($#files+1)*100) . "% Done"; }
	#skip files with the wrong ext, Also check that it is not . or .. since those are VERY dangerous
	if ($file =~ m/.*\.$ext/ && $file ne "." && $file ne "..") {
		#always true is $speedhack is 0, other wise skips $speedhack # of files and checks the very last file
		if ($speedhack == 0 || $count % $speedhack == 0 || $count == $#files) {
			if ($file =~ m/.*\.$ext/) {	
				#if image is dark store its name and deal with it later
				if (IsDark($file)) {
					#$file is dark
					push (@filesToRemove, $file);
					$speeddark = 1;
					if ($speeddark && $speedhack) {
						#if image was dark and last image was dark all images inbetween should be dark
						foreach my $f (@speedHist) { push(@filesToRemove, $f); }
					}
					elsif ($speedhack) {
						#if speed hack is enabled skipped files need to be checked
						foreach my $f (@speedHist) {
							if (IsDark($f)) { push(@filesToRemove, $f); }
						}
					}
				}
				elsif ($speeddark && $speedhack) {
					#if image was bright and last image was dark
					#check skipped images
					foreach my $f (@speedHist) {
						if (IsDark($f)) { push(@filesToRemove, $f); }
					}
					$speeddark = 0; #this image was light
				}
				#clear file history
				@speedHist = ();
			}
		}
		else {
			#add file to list of files skipped during this iteration
			push(@speedHist, $file);
		}
	}
}
print "\rScanning for dark images: DONE\n";
if ($#filesToRemove+1 > 0) {
	print "Dark images found!\n";
	my $cont = "\n";
	if ($force == 0) {
		#print a list of files to be removed
		foreach my $file (@filesToRemove) {
			print "Remove: $file\n";
		}
		print "Total file to remove: " . ($#filesToRemove+1) . "\n";
		print "To continue press enter otherwise enter any value:";
		#get user input (this will capture trailing \n)
		$cont = <STDIN>;
	}

	if ($cont eq "\n") {
		print "\nCreating temporary directory..\n";
		mkdir("$dir/removed/");	
		
		#remove all files identified as dark
		foreach my $file (@filesToRemove) {
			if ($verbose) {print "Moving: $dir/$file To $dir/removed/$file\n";}
			rename("$dir/$file","$dir/removed/$file") or die "Unable to move $file to removed/$file"; #rename == move
		}
	}
}
else {print "No Dark images found!\n";}

sub IsDark
{
	my @colordata;
	$colordata[0][0] = -1;
	$colordata[0][1] = -1;
	my $colorindex = -1;
	my $file = @_[0];
	#use imagemagick to get picture information, piped into DATA
	open(DATA, "identify -verbose  \"$dir/$file\"|");
	#Extract mean and skewness from output 
	while (<DATA>) {
		#use regexpressions to get data. In newer versions of imagemagick there is no capitalization..
		#(?: ) is a non capturing group vs. ( ) which captures and is stored in $1 $2 etc.
		#\s* is any amount of whitespace, used lberally to prevent updates from breaking the script
		if ($_ =~ m/\s*(?:R|r)ed:\s*/) {
			$colorindex = 0;
		}
		elsif ($_ =~ m/\s*(?:G|g)reen:\s*/) {
			$colorindex = 1;
		}
		elsif ($_ =~ m/\s*(?:B|b)lue:\s*/) {
			$colorindex = 2
		}
		elsif ($_ =~ m/\s*(?:M|m)ean: (\d*\.\d*)\s*( \(\d*\.\d*\))?\s*/) {
			$colordata[$colorindex][0] = $1;
		}
		elsif ($_ =~ m/\s*(?:S|s)tandard (?:D|d)eviation: (\d*\.\d*)\s*( \(\d*\.\d*\))?\s*/) {
			$colordata[$colorindex][1] = $1;
		}
	}	
	close DATA;
	
	if ($colordata[0][0] == -1 || $colordata[0][1] == -1 || $colorindex == -1) {
		die "ImageMagick Parsing Failure";
	}

	my $dark = 1; #dark unless otherwise proven by jury trial
	for (my $i = 0; $i < 3; $i++) {
		#print "$colordata[$i][0] | $colordata[$i][1]\n";
		#if mean or standard deviation is above threshold image is not dark
		if ($colordata[$i][0] > $threshold[0]) {
			$dark = 0;
			last;
		}
		elsif ($colordata[$i][1] > $threshold[1]) {
			$dark = 0;
			last;
		}  
	}
	#if ($dark) { print "DARK \n"; }
	return $dark;
}
