//
// Filename:  val.cc
// Author:    Marc Anderson
// Compiler:  GNU C++ 2.6.0
// Copyright 1994, All Rights Reserved
//
// Description:
//    implementation of single tests for Valkyrie project validation library
//  
//    also code to handle errors appropriately depending on run mode
//
// Methods:
//    ValTest::error_handle()
//
//    ValVarref::get_name()
//
//    ValVarref::get_winput_avg()
//
//    ValVarref::get_winput_SR()
//
//    ValVarref::get_winput_SR_range()
//
//    ValVarref::get_winput_SR_freq()
//
//    ValVarref::get_winput_HR()
//
//    ValVarref::get_winput_HR_range()
//
//    ValTestRange::test()
//
//    ValTestFlatline::ValTestFlatline()
//
//    ValTestFlatline::test()
//
//    ValTestLevel::test()
//
// Global Functions:
//
// Local Functions:
//
//

#define VAL_C

/*
extern "C" {
#include <string.h>
#include <time.h>
#include <iostream.h>
#include <stdio.h>
}
*/
#include <cstring>
#include <time.h>
#include <iostream>
#include <cstdio>

#include "stddefs.h"
#include "val.h"




//
// error message constants
//
// (note that these messages cannot be longer than SOCK_MSGLEN (message.h))
//

static const char *range_msg_low =       "out of range low-prio";
static const char *range_msg_high =      "out of range high-prio";

static const char *flatline_msg_low =    "flatline low-prio";
static const char *flatline_msg_high =   "flatline high-prio";

static const char *spike_msg_high =      "spike high-prio";

static const char *level_msg_high =      "level shift high-prio";

static const u_int16 CONSEC_NUMMIN = 2;   // (consec counter is last 2 min)



///////////////////////////////////////////////////////////////////////////////
//
// class ValTest methods
//



//
// ValTest::error_handle()
//
// handle errors when they are generated by ValTest children classes
//
// [note 1]
//
// at some point there will probably need to be a distinction here
// between realtime mode and postprocessing mode, so we know how
// to route the messages
//
// for a postprocessing test with multiple variable names, this only
// deals with the first one, etc.  this means that postprocessing
// tests will definitely have to be dealt with differently.
//
void ValTest::error_handle(ValErrorMsg val_msg, char *current_timestr,
			   int current_elapsed)
{
    Message *socket_msg = new Message;

    if(!socket_msg)
    {
	cerr << "QC: ValTest::error_handle(): memory alloc error\n";
	return;
    }

    // fill in the fields of messages to the socket library

    strncpy(socket_msg->vname, vars[0].get_name(), SOCK_NAMELEN);
    socket_msg->sev            = val_msg.sev;

    // convert enumerated type constant into a string
    // (must be appended if new validation tests are eve incorporated)
    switch(val_msg.type)
    {
      case TYPE_RANGE:
	strncpy(socket_msg->type, VAL_RANGESTR, SOCK_TYPELEN); break;

      case TYPE_FLATLINE:
	strncpy(socket_msg->type, VAL_FLATLINESTR, SOCK_TYPELEN); break;

      case TYPE_SPIKE:
	strncpy(socket_msg->type, VAL_SPIKESTR, SOCK_TYPELEN); break;

      case TYPE_SHIFT:
	strncpy(socket_msg->type, VAL_LEVELSTR, SOCK_TYPELEN); break;
	
      default:
	strncpy(socket_msg->type, "unknown !!?", SOCK_TYPELEN); // break;
    }

    socket_msg->val            = vars[0].get_winput_avg(); //current avg value?

    strncpy(socket_msg->message, val_msg.message, SOCK_MSGLEN);

    // some tests treat conesecutive counters differently
    if((val_msg.type == TYPE_FLATLINE) || (val_msg.type == TYPE_SHIFT))
    {
	// i guess these statistics are irrelevent for flatline/shifts 
	socket_msg->Count_Consec   = 0;
	socket_msg->Count_last2min = 0;
    }
    else
    {
	// maintain 'last 2 minutes' log only if we have to....
	// log this entry in the queue & eliminate out-of-date queue entries

        if(!time_queue.enqueue(current_elapsed))
	{
	    cerr << "QC: error allocating queue entry for last2min\n";
	    delete socket_msg;
	    return;
	}

        while((time_queue.at_head() != NULL_TIME) &&
	      ((current_elapsed - time_queue.at_head()) >= (CONSEC_NUMMIN*60)))
	{
	    (void) time_queue.dequeue();
	}

	// algorithm to determine consecutive count
        if(current_elapsed == (lasterror_elapsed + 1))
	  ++consec_counter;
	else
	  consec_counter = 1;

	lasterror_elapsed = current_elapsed;


	// fill fields into socket message
	socket_msg->Count_Consec   = consec_counter;
	socket_msg->Count_last2min = time_queue.get_num_items(); 
    }


    strcpy(socket_msg->Timestamp, current_timestr);

    //(old ways of generating timestamp, in case they ever become needed 
    //again):

    //  timestruct = * (gmtime(&current_time));
    //  strftime(socket_msg->Timestamp, SOCK_TSLEN-1, "%H:%M:%S", &timestruct);

    //  strcpy(socket_msg->Timestamp, timebuf);  // need min ~26 chars
    //  crptr = strstr(socket_msg->Timestamp, "\n");
    //  *crptr = '\0';

#ifdef VAL_USEGUI
    // this puts message on a queue and eventually sends it, and then
    // deallocates dynamic memory.. (unparanthetical dynamic memory -- yuck)
    val_socket->Send(socket_msg);
#endif // VAL_USEGUI
    

#ifdef VAL_DISKLOG
    val_disklog->form("%s %-10s --> %s\n", 
		      socket_msg->Timestamp,
		      vars[0].get_name(), 
		      socket_msg->message);
#endif

#ifdef VAL_DIAGS
    cout.form("QC: vallib: %s %-10s --> %s\n", 
	      socket_msg->Timestamp,
	      vars[0].get_name(), 
	      socket_msg->message);
#endif


#ifdef VAL_USEGUI
    val_socket->flushQ();      // I question the necessity of this -marc !!!!
#else                        
    delete socket_msg;         //  (flushQ deletes msg automatically)
#endif
}



///////////////////////////////////////////////////////////////////////////////
//
// class ValVarref methods for referencing WINPUT databases and such
//



//
// ValVarref::get_name()
//
// get name of an arbitary winput variable (maybe should copy?)
//
char *ValVarref::get_name(void)
{
    switch(type)
    {
      case WINPUT_SDI:     
	return sdi[index]->name;

      case WINPUT_RAW:	
	return raw[index]->name;

      case WINPUT_DERIVED: 
	return derived[index]->name;

      default:          
	return NULL;  // (invalid type)
    }
}


//
// ValVarref::get_winput_avg()
//
// get 'average' data value from an arbitrary winput database
//
WinputDatavalue ValVarref::get_winput_avg(void)
{
    switch(type)
    {
      case WINPUT_SDI:      return AveragedData[sdi[index]->LRstart];
      case WINPUT_RAW:      return AveragedData[raw[index]->LRstart];
      case WINPUT_DERIVED:  return AveragedData[derived[index]->LRstart];
      default:              return (WinputDatavalue) VALTEST_INVALID_TYPE;
    }
}


//
// ValVarref::get_winput_SR()
//
// get 'sample rate' value from an arbitrary winput database
//
// sample_index == 0 .. (num samples-1)   (where 0 is oldest in time)
//
WinputDatavalue ValVarref::get_winput_SR(WinputHRindex sample_index)
{
    // perhaps naively, we assume that 'sample_index' is correct
    // ... also, are all of these situations valid ???
    switch(type)
    {
      case WINPUT_SDI:
	return SampledData[sdi[index]->SRstart + sample_index];
	
      case WINPUT_RAW:
	return SampledData[raw[index]->SRstart + sample_index];
	
      //case WINPUT_DERIVED:  (unsupported feature)
      //   return SampledData[derived[index]->SRstart + sample_index];
	
      default:
	return (WinputDatavalue) VALTEST_INVALID_TYPE;
    }
}



//
// ValVarref::get_winput_SR_range()
//
// get a range of 'sample rate' data values from an arbitrary winput database
//
// *_index == 0 .. (num samples)   (where 0 is oldest in time)
//
// returns TRUE on success or FALSE on failure
//
boolean ValVarref::get_winput_SR_range(WinputDatavalue *dest,
				       WinputSRindex start_index,
				       WinputSRindex end_index)
{
    WinputSRindex count, base_index, num_to_copy;

    // ... are all of these situations valid ???
    switch(type)
    {
      case WINPUT_SDI:
	base_index = sdi[index]->SRstart + start_index;
	break;
	    
      case WINPUT_RAW:
	base_index = raw[index]->SRstart + start_index;
	break;
	
      //case WINPUT_DERIVED:  (not supported by NIMBUS)
      //   base_index = derived[index]->SRstart + start_index;
      //   break;

      default:
	cerr << "QC: ValVarref::get_winput_SR_range(): invalid type\n";
	return false;
    }

    // perform copy
    num_to_copy = end_index - start_index;
    for(count=0; count<num_to_copy; ++count)
      dest[count] = SampledData[base_index + count];

    return true;
}



//
// ValVarref::get_winput_SR_freq()
//
// get 'sample rate' frequency for an arbitrary winput variable
//
// (and thus the number of samples)
//
// (i.e. 1000 hz == 1000 samples)
//
WinputSRfreq ValVarref::get_winput_SR_freq(void)
{
    // (I assume such a winput frequency parameter exists)
    switch(type)
    {
      case WINPUT_SDI:     return (WinputSRfreq) sdi[index]->SampleRate;
      case WINPUT_RAW:     return (WinputSRfreq) raw[index]->SampleRate;
      //case WINPUT_DERIVED: return (WinputSRfreq) derived[index]->SampleRate;
      default:             return (WinputSRfreq) VALTEST_INVALID_TYPE;
    }
}



//
// ValVarref::get_winput_HR()
//
// get 'high rate' value from an arbitrary winput database
//
// sample_index == 0 .. (num samples-1)   (where 0 is oldest in time)
//
WinputDatavalue ValVarref::get_winput_HR(WinputHRindex sample_index)
{
    // perhaps naively, we assume that 'sample_index' is correct
    switch(type)
    {
      case WINPUT_SDI:
	return HighRateData[sdi[index]->HRstart + sample_index];
	
      case WINPUT_RAW:
	return HighRateData[raw[index]->HRstart + sample_index];
	
      case WINPUT_DERIVED:
	return HighRateData[derived[index]->HRstart + sample_index];
	
      default:
	return (WinputDatavalue) VALTEST_INVALID_TYPE;
    }
}


//
// ValVarref::get_winput_HR_range()
//
// get a range of 'high rate' data values from an arbitrary winput database
//
// *_index == 0 .. (num samples-1)   (where 0 is oldest in time)
//
// returns TRUE on success or FALSE on failure
//
boolean ValVarref::get_winput_HR_range(WinputDatavalue *dest,
				  WinputHRindex start_index,
				  WinputHRindex end_index)
{
    WinputHRindex count, base_index, num_to_copy;

    // ... are all of these situations valid ???
    switch(type)
    {
      case WINPUT_SDI:
	base_index = sdi[index]->HRstart + start_index;
	break;
	
      case WINPUT_RAW:
	base_index = raw[index]->HRstart + start_index;
	break;

      case WINPUT_DERIVED:
	base_index = derived[index]->HRstart + start_index;
	break;

      default:
	cerr << "QC: ValVarref::get_winput_HR_range(): invalid type\n";
	return FALSE;
    }

    num_to_copy = end_index - start_index;
    for(count=0; count<num_to_copy; ++count)
      dest[count] = HighRateData[base_index + count];

    return TRUE;
}





///////////////////////////////////////////////////////////////////////////////
//
// specific ValTest child classes -- actual validation test classes
//


//
// ValTestRange::test()
//
// perform simple 'range' validation test
//
ValTestRtn ValTestRange::test(char *current_timestr, int current_elapsed)
{
    WinputDatavalue current_value = vars[0].get_winput_avg();
    ValTestRtn rtn = VAL_PASSED;

    if(current_value <= (low_thresh - highprio_delta))
    {
	error_handle(ValErrorMsg(SEV_HIGH, TYPE_RANGE, range_msg_high),
		     current_timestr, current_elapsed);
	rtn = VAL_FAILED_HIGH;
    }

    else if(current_value <= low_thresh)
    {
	error_handle(ValErrorMsg(SEV_LOW, TYPE_RANGE, range_msg_low),
		     current_timestr, current_elapsed);
	rtn = VAL_FAILED_LOW;
    }

    else if(current_value >= (high_thresh + highprio_delta))
    {
	error_handle(ValErrorMsg(SEV_HIGH, TYPE_RANGE, range_msg_high),
		     current_timestr, current_elapsed);
	rtn = VAL_FAILED_HIGH;
    }    

    else if(current_value >= high_thresh)
    {
	error_handle(ValErrorMsg(SEV_LOW, TYPE_RANGE, range_msg_low),
		     current_timestr, current_elapsed);
	rtn = VAL_FAILED_LOW;
    }

    return(rtn);
}



//
// ValTestFlatline::ValTestFlatline()
//
// constructor for flatline object -- needs to initialize history log
//
ValTestFlatline::ValTestFlatline(ValVarref &ref, ValVariance temp_low,
				     ValVariance temp_high) :
   ValTest(&ref)
{
    u_int16 count;
        
    min_var_low = temp_low;
    min_var_high = temp_high;

    for(count=0; count<VAL_FLATLINE_NUMHIST; ++count)
      history[count] = 0;   // hope this is ok initialization value
}




//
// ValTestFlatline::test()
//
// test for flatline (i.e. too little variance)
//
ValTestRtn ValTestFlatline::test(char *current_timestr, 
int current_elapsed)
{
    WinputDatavalue current_value = vars[0].get_winput_avg();
    u_int16 count;
    ValVariance sum = 0, sum_sq = 0, temp_ss, variance;
    ValTestRtn rtn = VAL_PASSED;

    
    // make room in history log for new value
    for(count=VAL_FLATLINE_NUMHIST-1; count>0; --count)
      history[count] = history[count-1];

    // store new value
    history[0] = current_value;

    // (now calculate variance over history log)

    for(count=0; count<VAL_FLATLINE_NUMHIST; ++count)
    {
	sum += history[count];
	sum_sq += history[count] * history[count];
    }

    temp_ss = (sum_sq - sum * sum / (real32) VAL_FLATLINE_NUMHIST);

    // calculate variance (factor out bias)
    variance = temp_ss / (real32) (VAL_FLATLINE_NUMHIST - 1);

    if(variance <= min_var_high)
    {
	error_handle(ValErrorMsg(SEV_HIGH, TYPE_FLATLINE, flatline_msg_high),
		     current_timestr, current_elapsed);
	rtn = VAL_FAILED_HIGH;
    }
    else if(variance <= min_var_low)
    {
	error_handle(ValErrorMsg(SEV_LOW, TYPE_FLATLINE, flatline_msg_low),
		     current_timestr, current_elapsed);
	rtn = VAL_FAILED_LOW;
    }

    return(rtn);
}


#define ABSVAL(x)   ((x) >= 0 ? (x) : -(x))



//
// available states in ValTestLevel state machine
//
enum ValLevelState
{
    StateSeek,        // scanning history log for initial level shift
    StateUpSlope,     // following the value go up in slope     
    StateDownSlope,   // following the value go down in slope
    StateReturnInit,  // initializer state for StateReturn
    StateReturn       // following the value go back to the initial region
};


//
// ValTestLevel::test()
//
// perform level check/spike detection algorithm as it was described
// in the design specification.  this is implemented as a state machine
// with the states listed above (enum ValLevelStat).  Each state
// corresponds to a different region of the level shift or spike
// we are detecting.
//
ValTestRtn ValTestLevel::test(char *current_timestr, int current_elapsed)
{
    WinputDatavalue diff;
    WinputSRindex count_history;
    WinputSRindex num_history = vars[0].get_winput_SR_freq();
    WinputDatavalue *history;
    WinputDatavalue val_beforeslope;
    ValLevelState state;
    ValSlope slope_accum;
    WinputSRindex return_count;

    // it's stupid that we have to do this dynamically rather than statically
    // to avoid the '-ansi' compiler complaint
    history = new WinputDatavalue[num_history];  // !! be sure to delete !!
    

    if(!history)
    {
	cerr << "QC: ValTestLevel::test(): out of memory -- error ignored\n";
	return VAL_PASSED;    // don't have a return type for memory failure
    }
    

    // get 1 second history log from WINPUT "sample rate" database
    vars[0].get_winput_SR_range(&history[0], 0, num_history-1);


    // (now perform test -- this is done as a state machine)

    state = StateSeek;
    count_history=1; 
    while(count_history<num_history)
    {
	diff = history[count_history] - history[count_history - 1];

	switch(state)
	{
	  // this state searches for a level shift that exceeds min_slope
	  //
	  // if an up shift occurs
	  //    if that shift also exceeded 'min_shift'
	  //       we can just skip StateUpShift and go to StateReturn
	  //    else
	  //       enter StateUpShift
	  // else if a down shift occurs
	  //    if that shift also exceeded 'min_shift'
	  //       we can just skip StateDownShift and go to StateReturn
	  //    else
	  //       enter StateDownShift
	  case StateSeek:
	    if(diff >= min_slope)
	    {
		val_beforeslope = history[count_history];

		slope_accum = diff;
		if(slope_accum >= min_shift)  
		  state = StateReturnInit;   
		else
		  state = StateUpSlope;      
	    }
	    else if(diff <= (-min_slope))
	    {
		val_beforeslope = history[count_history];

		slope_accum = diff;
		if(slope_accum <= (-min_shift))
		  state = StateReturnInit;
		else
		  state = StateDownSlope;
	    }
	    // else did not move enough to justify spike error or level shift
	    break;


	  // following slope in upward direction
	  //
	  // if difference exceeded min_slope
	  //    keep accumulating differences
	  //    if accumulator exceed 'min_shift' 
	  //       go to StateReturn
	  // else 
	  //    return to Seek state
	  case StateUpSlope:
	    if(diff >= min_slope)
	    {
		slope_accum += diff;
		if(slope_accum >= min_shift)
		    state = StateReturnInit;
	    }
	    else
	      state = StateSeek;
	    break;
	    
	  // following slope in downward direction (opposite as StateUpSlope)
	  case StateDownSlope:
	    if(diff <= (-min_slope))
	    {
		slope_accum += diff;
		if(slope_accum <= (-min_shift))
		  state = StateReturnInit;
	    }
	    else 
	      state = StateSeek;
	    break;

	  // prepare for StateReturn  (this is one cycle after StateXSlope)
	  case StateReturnInit:
	    return_count = 1;
	    state = StateReturn;
	    // falls through

	  // this state watches value after peak
	  // 
	  // if 'spike_peak_maxintvls' exceeded
	  //    generate level shift error (too late for spike to return)
	  // else if value returns to the region before the slope began 
	  // (+- slack)
	  //    generate a spike error, 
	  //
	  // (note if spike_peak_maxintvls == 0 then this does correct
	  // thing -- i.e. no spike detection)
	  //
	  //

	  case StateReturn:
	    // must be done before 'IS_BTWN_OR_EQUAL' if we wanna handle
	    // condition when spike_peak_maxintvls == 0
	    if(return_count > spike_peak_maxintvls)
	    {
	        // generate level shift error 
		error_handle(ValErrorMsg(SEV_HIGH, TYPE_SHIFT,
					 level_msg_high), current_timestr,
			                  current_elapsed);
		    
		delete history;

		return(VAL_FAILED_HIGH);
	    }
	    else if(IS_BTWN_OR_EQUAL(history[count_history],
				     val_beforeslope - spike_rtn_slack,
				     val_beforeslope + spike_rtn_slack))
	    {
		// returned to buffer region before slope began -- therefore
	        // generate spike error
	     
	        error_handle(ValErrorMsg(SEV_HIGH, TYPE_SPIKE, 
					 spike_msg_high), current_timestr,
			                   current_elapsed);
		delete history;

		return(VAL_FAILED_HIGH);
	    }

	    // increment counter of number of samples after peak (initially 1)
	    ++return_count;
	    
	    break;

	  default:
	    return(VAL_FAILED_HIGH);   // invalid state -- should never happen
	} // end switch

	++count_history;
    } // end while

    delete history; 
    

    // reached end of history log with no definite error -- now decide
    // what to do based on state....
    switch(state)
    {
      case StateSeek: 
      case StateUpSlope: 
      case StateDownSlope:
	// exiting in none of these states justifies an error
	return(VAL_PASSED);

      case StateReturn:
	// generate level shift error
	error_handle(ValErrorMsg(SEV_HIGH, TYPE_SHIFT, level_msg_high),
		     current_timestr, current_elapsed);

	return(VAL_FAILED_HIGH);

      default:
	return(VAL_FAILED_HIGH);   // invalid state -- should never happen
    }
}



//////////////////////////////////////////////////////////////////////////////
//
// ValTimeQueue methods
//
// (for maintaining last2min counter)
//

// 
// ValTimeQueue::dequeue()
//
// dequeue item at head of queue, checking for errors and such
//
// returns NULL_TIME on failure, else returns time that was dequeued
//
int ValTimeQueue::dequeue(void)
{
    int temp_time = at_head();

    if(temp_time != NULL_TIME)   // if not zero than there was _not_ an error
       delete ValQueue::dequeue();   // should never core dump here (!)

    return temp_time;
}


//
// ValTimeQueue::enqueue()
//
// enqueue item to end of queue, checking for errors and such
//
// returns TRUE on success or FALSE on failure (i.e. memory alloc error)
//
boolean ValTimeQueue::enqueue(int new_time)
{
    ValTimeQueueNode *new_node = new ValTimeQueueNode(new_time);

    if(!new_node)
      return FALSE;
    else
    {
	ValQueue::enqueue((ValQueueNode *) new_node);
	return TRUE;
    }
}



//
// ValTimeQueue::at_head()
//
// returns item at head of queue without dequeueing it, or NULL_TIME if
// the queue is empty
//
int ValTimeQueue::at_head(void)
{
    ValTimeQueueNode *temp_node = (ValTimeQueueNode *) ValQueue::at_head();
    
    if(temp_node) 
      return temp_node->error_time;
    else
      return NULL_TIME;
}

