/* HwIrs.cc

   Honeywell YG1854 IRS interface class.

   Original Author: Jerry V. Pelk
   Copyright by the National Center for Atmospheric Research
 
   Revisions:
 
*/

#include <HwIrs.h>

/******************************************************************************
** Public Functions
******************************************************************************/

HwIrs::HwIrs (IP429 *ip, Bc635Vme &tp, int rxchan, 
       	      int txchan) : tfp (tp)
         
// Constructor.
{
  ip429 = ip;
  rx_chan = rxchan;
  tx_chan = txchan;

  ptog = 0;
  gtog = 0;
  idx50 = 0;
  idx25 = 0;
  idx10 = 0;
  idx5 = 0;
  idx2 = 0;
  newSecond = FALSE;
  last_alt = 0.0;
  memset ((char*)irs_blk, 0, sizeof (irs_blk));

  cur_drift = 0;
  cur_gnd_speed = 0;
  cur_inertial_alt = 0;
  cur_lat = 0;
  cur_lon = 0;
  cur_pitch = 0;
  cur_roll = 0;
  cur_true_heading = 0;

  if (tx_chan) {
    ip429->setSpeedLow (tx_chan);		// transmit at low speed
    setTasAlt (0.0, 0.0);			// set default values
  }

  setupIndices();

}

/*****************************************************************************/
void HwIrs::secondAlign ()

// Called at the start of a second to align the indices and toggle buffers.
{
  newSecond = TRUE;			// set the new second flag
  gtog = ptog;                   	// toggle the get buffer index 
}

/*****************************************************************************/
void HwIrs::setTasAlt (float tas, float alt)

// Builds the arinc 429 format tas, altitude, and altitude rate words.
// This routine is called once per second.
{
  float rate;

// True air speed (kts). 
  tas *= (float)SECS_PER_HOUR / METERS_PER_NAUT;	// convert m/s to kts	
  tas_alt[HW_TAS_IDX] = ((int)((tas / 2048.0) * 2147483648.0) & 0xfffff800) +
                       ARINC_SSM_VALID + ARINC_TAS_LABEL;

// Altitude (feet).
  alt *= (float)FEET_PER_METER;		// convert altitude to feet
  tas_alt[HW_ALT_IDX] = ((int)((alt / 131072.0) * 2147483648.0) & 0xfffff800) +
                       ARINC_SSM_VALID + ARINC_PALT_LABEL;

// Altitude rate (feet/min) is computed as the change from the last altitude
// times SECS_PER_MIN, since this routine is called once per second.
  rate = (alt - last_alt) * (float)SECS_PER_MIN;
  tas_alt[HW_ALT_RATE_IDX] = 
                ((int)((rate / 32768.0) * 2147483648.0) & 0xfffff800) +
                ARINC_SSM_VALID + ARINC_PALT_RATE_LABEL;

  last_alt = alt;			// save the altitude value

//printf ("tas = %f, alt = %f, rate = %f\n", tas, alt, rate);
//printf ("tas_alt[] = %X %X %X\n", tas_alt[0], tas_alt[1], tas_alt[2]);
}

/*****************************************************************************/
void HwIrs::readIsr ()
{
  long	arinc_data;
  int	label;

  // Read the data words from the arinc interface.
  *(short*)(((char*)&arinc_data) + sizeof(short)) = ip429->data1 (rx_chan);
  *(short*)&arinc_data = ip429->data2 (rx_chan);
  label = arinc_data & ARINC_LABEL_MASK;

//  logMsg("arinc_data = %X\n",arinc_data,0,0,0,0,0);


  // Add lags.
  switch (label)  	// switch on the arinc label
    {
    // The 50 Hz parameters 
    case 0265:			// first 50 hz param, starts a new block
      if (newSecond) {					// check for new second
        long lag;

        lag = tfp.readMsec(); 				// read 50 hz lag
        togglePut();					// toggle put buffer
        irs_blk[ptog].lag_50hz_frame = lag;	 	// set 50 hz lag
        newSecond = FALSE;
      }
      break;

    // 25 Hz parameters 
    case 0313:                        			// first 25 Hz param
      if (!sample[0313])                                // check for new sec
        irs_blk[ptog].lag_25hz_frame = tfp.readMsec(); 	// read 25 hz lag
      break;

    // The 10 Hz parameters
    case 0312:						// first 10 Hz param
      if (!sample[0312])				// check for new sec
        irs_blk[ptog].lag_10hz_frame = tfp.readMsec();	// read 10 hz lag
      break;
 
    // 5 Hz parameters
    case 0310:						// first 5 Hz param
      if (!sample[0310])				// check for new sec
        irs_blk[ptog].lag_5hz_frame = tfp.readMsec(); 	// read 5 hz lag
      break;
    }

  (indices[label] + (ptog * (sizeof(Irs_blk)>>2)))[sample[label]] = arinc_data;
  ++sample[label];

}
/******************************************************************************
** Private Functions
******************************************************************************/

void HwIrs::togglePut ()

// Fills in any missing samples due to walking clocks, resets the buffer
// indices, and toggles the put index.
{
  int	i;

  for (i = 0; i < 256; ++i)
    sample[i] = 0;

  idx50 = idx25 = idx10 = idx5 = idx2 = 0;
  ptog = ++ptog % TOG;

  memset((char *)&irs_blk[ptog], 0, sizeof(irs_blk[ptog]));
}

/*****************************************************************************/
void HwIrs::setupIndices()
{
  int	i, MIN_LABEL = 0;

  for (i = 0; i < 256; ++i)
    {
    indices[i] = &dummy[0];
    sample[i] = 0;
    }

  indices[0265 - MIN_LABEL] = irs_blk[0].integ_vert_accel;
  indices[0324 - MIN_LABEL] = irs_blk[0].pitch_angle;
  indices[0325 - MIN_LABEL] = irs_blk[0].roll_angle;
  indices[0326 - MIN_LABEL] = irs_blk[0].pitch_rate;
  indices[0327 - MIN_LABEL] = irs_blk[0].roll_rate;
  indices[0330 - MIN_LABEL] = irs_blk[0].yaw_rate;
  indices[0331 - MIN_LABEL] = irs_blk[0].long_accel;
  indices[0332 - MIN_LABEL] = irs_blk[0].lat_accel;
  indices[0333 - MIN_LABEL] = irs_blk[0].normal_accel;
  indices[0335 - MIN_LABEL] = irs_blk[0].track_ang_rate;
  indices[0336 - MIN_LABEL] = irs_blk[0].pitch_att_rate;
  indices[0337 - MIN_LABEL] = irs_blk[0].roll_att_rate;
  indices[0360 - MIN_LABEL] = irs_blk[0].pot_vert_speed;
  indices[0364 - MIN_LABEL] = irs_blk[0].vertical_accel;

  indices[0313 - MIN_LABEL] = irs_blk[0].track_angle_true;
  indices[0365 - MIN_LABEL] = irs_blk[0].inrt_vert_speed;
  indices[0361 - MIN_LABEL] = irs_blk[0].inertial_alt;
  indices[0321 - MIN_LABEL] = irs_blk[0].drift_angle;
  indices[0314 - MIN_LABEL] = irs_blk[0].true_heading;

  indices[0312 - MIN_LABEL] = irs_blk[0].ground_speed;
  indices[0315 - MIN_LABEL] = irs_blk[0].wind_speed;
  indices[0316 - MIN_LABEL] = irs_blk[0].wind_dir_true;
  indices[0366 - MIN_LABEL] = irs_blk[0].velocity_ns;
  indices[0367 - MIN_LABEL] = irs_blk[0].velocity_ew;
  indices[0334 - MIN_LABEL] = irs_blk[0].platform_hdg;

  indices[0310 - MIN_LABEL] = irs_blk[0].present_lat;
  indices[0311 - MIN_LABEL] = irs_blk[0].present_lon;
  indices[0370 - MIN_LABEL] = irs_blk[0].norm_accel;

  indices[0350 - MIN_LABEL] = irs_blk[0].irs_maint_discretes;
  indices[0270 - MIN_LABEL] = irs_blk[0].irs_discretes;
  indices[0371 - MIN_LABEL] = irs_blk[0].equipment_id;
  indices[0351 - MIN_LABEL] = irs_blk[0].time_to_nav_ready;


}
