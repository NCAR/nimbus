# -*- python -*-

import os
import sys
import re

# This is for building in the RAF source tree.  When building standalone,
# site_scons is checked out directly into this directory (or else into
# ~/.scons/site_scons) and that takes precedence.
sys.path.append(os.path.abspath("../../caledit/site_scons"))
import eol_scons

env = Environment(tools=['default', 'netcdf', 'postgres_pq', 
                         'boost_date_time', 'postgres_testdb',
                         'prefixoptions', 'jlocal', 'testing'])

def actrack(env):
    # Tool to configure the library build.  The actrack library itself is
    # not included to make it possible to link against different build
    # variants.
    env.Require(['netcdf', 'postgres_pq', 'boost_date_time'])
    if env.Dir('.').get_abspath().endswith('sanitized'):
        env.SanitizeAddress()
    elif env.Dir('.').get_abspath().endswith('clang'):
        env['CC'] = os.environ.get('CC', env['CC'])
        env['CXX'] = os.environ.get('CXX', env['CXX'])

Export('actrack')

(libactrack, actrackkml, actrackx) = SConscript('SConscript')
libactrackpub = libactrack
env.Default(actrackkml)
env.Default(actrackx)

Alias('install', env.Install('$JLOCAL/bin', 'acTrack2kml'))

rootenv = env

# ----------------------------------------------------------------------------
# Python module
# ----------------------------------------------------------------------------

env = env.Clone()
env.MergeFlags('!python-config --includes')
env.Append(LIBS=['boost_python', libactrackpub])
env.Require('actrack')

module = env.SharedLibrary(env.File('raf/actrack/_actrack.so'), 
                           ['actrack_python.cc'])
# I don't know why this Depends() is necessary, but the library does not
# get rebuilt without it.  SCons may not realize that the static
# libactrack.a is a LIBS dependency even though the target is a shared
# library.
env.Depends(module, libactrackpub)
pysrcs = Split("raf/actrack/__init__.py")
tests = Split("raf/actrack/test_actrack.py")

# test_actrack.py needs DATA_DIR to find test data
env['ENV']['DATA_DIR'] = os.environ['DATA_DIR']
runtest = env.TestRun('pytests', tests+module+pysrcs, "py.test ${SOURCE}")

# ----------------------------------------------------------------------------
# Testing
# ----------------------------------------------------------------------------

env = Environment(tools=['default', 'actrack', 'postgres_testdb', 'testing',
                         'datafilecache'])

env['ACTRACKOPTS'] = '--path timestep'

# Testing uses instrumented code, unless instrumenting not supported.
if env.SanitizeSupported():
    (libactrack, actrackkml, actrackx) = SConscript('SConscript', 
                                                    variant_dir='sanitized', 
                                                    duplicate=1)

# Clang analysis works by running the scons build under the scan-build
# program, which replaces the CC and CXX environment variables with the
# paths to the clang analyzer executables.  So if CC is not set in the
# environment to one of those executables, then we are not really set up to
# run a clang analysis.  Someday this should be part of a clang analyzer
# scons tool.  Maybe the CC and CXX paths should be overridden by the tool,
# rather than requiring the use of scan-build, but I think scan-build also
# sets up other artifacts like the reports directory.
if env.Detect('scan-build') and os.environ.get('CC', "").endswith('analyzer'):
    (libactrack, actrackkml, actrackx) = SConscript('SConscript', 
                                                    variant_dir='clang', 
                                                    duplicate=1)

dfcache = env.DataFileCache()
dfcache.setPrefix('rafdata:/scr/raf_data')
dfcache.insertCachePath('~/Data/raf/Prod_Data')

# Generate KML from a netcdf file.
def NetcdfKML(target, source, env):
    ifile = str(env.File(source[0]))
    ofile = str(env.File(target[0]))
    jfile = ""
    if len(target) > 1 and str(target[1]).endswith('.json'):
        jfile = str(env.File(target[1]))
    cmd = "${ACTRACK2KML} ${ACTRACKOPTS} %s %s %s" % (ifile, ofile, jfile)
    env.Execute(env.AsanFilter(cmd))


def kml_emitter(source, target, env):
    ofile = str(env.File(target[0]))
    if not env.has_key('ACTRACK2KML'):
        env['ACTRACK2KML'] = actrackkml[0].get_abspath()
    return (target, source + [ env['ACTRACK2KML'] ])


env['BUILDERS']['NetcdfKML'] = Builder(action=NetcdfKML, emitter=kml_emitter)


hippopath = env.DownloadDataFile('HIPPO/HIPPO-2rf06.nc')
ekml = 'expected/HIPPO-2rf06.kml'
ejson = 'expected/HIPPO-2rf06.json'
akml = 'kml/HIPPO-2rf06.kml'
ajson = 'kml/HIPPO-2rf06.json'
(akml, ajson) = env.NetcdfKML([akml, ajson], hippopath)
env.Alias('asan', [akml, ajson])
env.Alias('test', env.Diff([ekml, akml]))
env.Alias('test', env.Diff([ejson, ajson]))
env.AlwaysBuild(akml)

tenv = Environment(tools=['default', 'actrack', 'testing', 'gtest_main'])
tenv.SanitizeAddress()
tenv.Append(LIBS=libactrack)
gtests = tenv.Program('gtests', ["test_track.cc"])

env.Alias('test', env.Command('gtest', gtests,
                              env.AsanFilter("${SOURCE.abspath}")))

pg = env.PostgresTestDB()

# Generate KML output from a database SQL file.  The source is the SQL dump
# and the target is the real-time.kml file.
def database_kml_emitter(target, source, env):
    # Turn KMLOUTPUT into a file node so we can use .dir substitution with
    # it.
    if env.has_key('KMLOUTPUT'):
        env['KMLOUTPUTDIR'] = str(env.File("$KMLOUTPUT").get_dir())
    return target, ["${ACTRACK2KML}"] + source

database_kml_builder = Builder(action=[
    pg.action_init,
    Mkdir("${TARGET.dir}"),
    "${SOURCES[0].abspath} ${ACTRACKOPTS} "
    "-v --once -p ${AIRCRAFT} -f ${TARGET.dir}/..",
    pg.action_destroy],
                               emitter=database_kml_emitter)

database_kml_output_builder = Builder(action=[
    pg.action_init,
    Mkdir("${KMLOUTPUTDIR}"),
    "${SOURCES[0].abspath} ${ACTRACKOPTS} "
    "-v --once -p ${AIRCRAFT} --output ${KMLOUTPUT}",
    pg.action_destroy],
                                      emitter=database_kml_emitter)

env.Append(BUILDERS = {'DatabaseRealtimeKML':database_kml_builder})
env.Append(BUILDERS = {'DatabaseOutputKML':database_kml_output_builder})


gvkml = env.DatabaseRealtimeKML("GV-actual/GE/real-time.kml",
                                "sql/real-time-GV.sql", AIRCRAFT='GV')
env.AlwaysBuild(gvkml)

# Only the GV SQL data has points, so add it to the test alias.  The C-130
# comparison fails because no files are generated.
#
env.Alias('test', env.Diff('testgv-kml',
                           ["GV-expected/GE/real-time.kml",
                            "GV-actual/GE/real-time.kml"]))
env.Alias('test', env.Diff('testgv-position',
                           ["GV-expected/position.json",
                            "GV-actual/position.json"]))
env.DatabaseOutputKML('kml/C130-real-time.kml', 'sql/real-time-C130.sql', 
                      AIRCRAFT='C130', KMLOUTPUT="kml/C130-")

# The DLR test just makes sure it terminates and exits successfully.
dlr = env.DatabaseOutputKML('kml/DLR-real-time.kml',
                            'sql/real-time-DLR.sql', 
                            AIRCRAFT='DLR', KMLOUTPUT='kml/DLR-')

rf13kml = env.DatabaseOutputKML(['kml/WINTER-rf13-real-time-timestep.kml',
                                 'kml/WINTER-rf13-real-time-headingstep.kml'],
                                'sql/real-time-WINTER-rf13.sql',
                                AIRCRAFT="C130", ACTRACK2KML=actrackx,
                                KMLOUTPUT='kml/WINTER-rf13-')

# Accumulate all the targets generated in the kml subdirectory.
kmldir = [dlr, rf13kml]

# Render the whole of RF13.
kmldir += env.Command('kml/WINTER-rf13.png', rf13kml, 
                      "./renderkml.py ${SOURCES} "
                      "-77.9957,28.9685,-74.2237,37.1555 ${TARGET}")

# Render just the figure eight.
kmldir += env.Command('kml/WINTER-rf13-loop.png', rf13kml, 
                      "./renderkml.py ${SOURCES} -77.9825,34.07,-77.7403,34.1869 "
                      "${TARGET}")

def RenderNetcdf(env, ncpath, bounds):
    if isinstance(ncpath, type("")):
        ncpath = env.DownloadDataFile(ncpath)
    ncfile = os.path.basename(str(ncpath))
    (base, ext) = os.path.splitext(ncfile)
    if ext != ".nc":
        base = ncfile
    base = "kml/" + base
    kmls = [base + "-timestep.kml", base + "-headingstep.kml"]
    kmls = env.Command(kmls, [actrackx, ncpath], [
            Mkdir("kml"),
            "${SOURCES[0].abspath} ${ACTRACKOPTS} ${SOURCES[1]} %s.kml" % (base)])
    png = env.Command(base + '.png', kmls, 
                      "./renderkml.py ${SOURCES} %s ${TARGET}" % (bounds))
    return kmls + png

kmldir += RenderNetcdf(env, hippopath, "172.236,-66.0481,187.508,-43.4905")
kmldir += RenderNetcdf(env, 'HIPPO/HIPPO-5rf13.nc',
                       "-150.438,60.1847,-145.201,87.0433")

kmldir += RenderNetcdf(env, 'WINTER/WINTERrf01.nc',
                       "-76.7107,37.0417,-71.1004,41.42")
kmldir += RenderNetcdf(env, 'WINTER/WINTERrf02.nc',
                       "-85.2695,37.0526,-76.2321,40.2853")
kmldir += RenderNetcdf(env, 'WINTER/WINTERrf03.nc',
                       "-76.4838,37.0583,-67.9553,42.3435")

# Generate all the .kml files as part of the test target, since they are
# quick.  The rendering (meaning the generation of all the .png files) is
# only done if explicitly requested, such as with the 'render' alias.

allkml = [kml for kml in kmldir if re.search('\.kml$', str(kml))]
env.Alias('test', allkml)

# Render a web page with all the WINTER tracks together.
allwinter = [kml for kml in kmldir if re.search('WINTER.*\.kml$', str(kml))]
kmldir += env.Alias('winter', env.Command('kml/WINTER.png', allwinter, 
                                       "./renderkml.py ${SOURCES} -86,30,-72,45 "
                                       "${TARGET}"))

if kmldir:
    env.Alias('render', kmldir)

# The 'expected' directory is a snapshot of all the known good and expected
# output files, so we can generate test targets which compare all of them.
for kml in allkml:
    kmlname = os.path.basename(str(kml))
    env.Alias('test', env.Diff('diff-'+kmlname, ['expected/'+kmlname, kml]))

# Generate html page for comparing plots.
page = env.ImageComparisonPage()
for png in [png for png in kmldir if re.search('\.png', str(png))]:
    pngname = os.path.basename(str(png))
    page.addComparison("expected/"+pngname, str(png))

html = page.build(env, "tracks.html")
env.Alias('render', html)

# Convenience targets in case anyone ever wants to download and test
# against a current real-time database.
env.DumpAircraftSQL('sql/real-time-GV.sql', 'GV')
env.DumpAircraftSQL('sql/real-time-C130.sql', 'C130')
env.DumpAircraftSQL('sql/real-time-N42RF.sql', 'N42RF')
env.DumpAircraftSQL('sql/real-time-DLR.sql', 'DLR')

env.SetHelp()
