# -*- python -*-

import os
env = Environment(platform = 'posix',ENV= os.environ)
env['JLOCAL'] = os.environ['JLOCAL']

env.Append(CXXFLAGS='-g -Werror -Wall')
env.Append(CPPPATH = '/usr/include/netcdf')
env.Append(LIBS = ['pq', 'boost_date_time'])

# To get netcdf libraries on the link command line with static linking,
# they need to be added to the end of the link command.  Adding them to
# LINKFLAGS does not work, because LINKFLAGS is expanded on the command
# line *before* LIBFLAGS.  There is no way to specify the libraries as
# static in LIBS, since members of LIBS are always expanded to -l<lib>.
# The only way to avoid that would be to replace the _stripixes() function,
# and I don't want to go there.  I've been there, and it's not pretty.

env['NETCDFLIBS'] = ['-lnetcdf_c++', '-lnetcdf', '-lhdf5_hl', '-lhdf5']
env['LINKCOM'] = env['LINKCOM'] + " $NETCDFLIBS"

# The Configure context is just being used as a check here.  We don't want
# the checks to affect the special linking setup above by appending
# libraries to LIBS.  Thus we create the context on a copy of the
# environment, and we don't use the Finish()ed product.  All the Configure
# checks appeared to do before were add -lnetcdf_c++ and -lpq to the LIBS,
# but those had already been given on the command line anyway.  Really this
# could be removed, since if netcdf or pq aren't installed, then the build
# will still fail.  However it's left here in case someday someone wants to
# really make it work.

conf = Configure(env.Clone())
#if not conf.CheckLibWithHeader('netcdf', 'netcdf.h', 'C'):
#    print 'netCDF must be installed!'
#    Exit(1)

#if not conf.CheckLibWithHeader('netcdf_c++', 'netcdf.hh', 'C++'):
#    print 'netCDF C++ must be installed!'
#    Exit(1)

#if not conf.CheckLibWithHeader('pq', 'libpq-fe.h', 'C'):
#    print 'PostgreSQL must be installed!'
#    Exit(1)

# As mentioned above, we need to ignore the alterations Configure
# makes to the environment.
# env = conf.Finish()

# If you rely on Configure to add libraries, you have to check for them in
# reverse order of their dependencies, ie, check for netcdf before
# netcdf_c++, otherwise netcdf_c++ cannot be linked.  However, when
# statically linking, that means the libraries need to be listed in LIBS in
# the reverse order they are checked by Configure.  Since at the moment
# Configure is not being used to add to LIBS, we don't need this.
# env['LIBS'].reverse()

# print env.Dump()

act = env.Program(['acTrack2kml.cc', 'Config.cc',
                   'AircraftTrackKML.cc',
                   'AircraftTrack.cc',
                   'acDatabase.cc',
                   'ncTrack.cc',
                   'osm.cc'])

Alias('install', env.Install('$JLOCAL/bin', 'acTrack2kml'))


# Find aircraft production netcdf files to test against.

def FindAircraftData(filename):
    searchdirs = ['$DATA_DIR/HIPPO', '/scr/raf_data/HIPPO']
    for d in searchdirs:
        d = os.path.expandvars(d)
        path = os.path.join(d, filename)
        if os.path.exists(path):
            print("found %s in %s" % (filename, path))
            return path
    return None


def BatchKML(target, source, env):
  ifile = env.File(source[0]).get_abspath()
  ofile = env.File(target[0]).get_abspath()
  if os.path.exists(ofile):
    os.unlink(ofile)
  env.Execute("${ACTRACK2KML} %s %s" % (ifile, ofile))


def kml_emitter(source, target, env):
  if not env.has_key('ACTRACK2KML'):
      env['ACTRACK2KML'] = act
  return (target, source + [ env['ACTRACK2KML'] ])


env['BUILDERS']['BatchKML'] = Builder(action=BatchKML, emitter=kml_emitter)

ncpath = FindAircraftData('HIPPO-2rf06.nc')
if ncpath:
    ekml = 'HIPPO-2rf06.kml'
    akml = 'HIPPO-2rf06-actual.kml'
    env.BatchKML(akml, ncpath)
    env.Alias('xdiff', 
              env.Command("diff", [ekml, akml],
                          "diff --side-by-side --width=170 ${SOURCES}"))
    env.Alias('test', 
              env.Command("diff", [ekml, akml],
                          "diff ${SOURCES}"))


