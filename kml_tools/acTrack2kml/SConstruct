# -*- python -*-

import os
import sys
import difflib

# This is for building in the RAF source tree.  When building standalone,
# site_scons is checked out directly into this directory and that takes
# precedence.
sys.path.append(os.path.abspath("../../caledit/site_scons"))
import site_init

env = Environment(tools=['default', 'netcdf', 'postgres_pq', 
                         'boost_date_time', 'postgres_testdb'])
env['JLOCAL'] = os.environ['JLOCAL']

env.Append(CXXFLAGS='-g -Werror -Wall')

# ------------------------------------------------------------------------
# All the talk beneath here about static linking appears to be obsolete,
# since near as I can tell the current system installation of acTrack2kml
# uses dynamic linking of netcdf and probably has for some time, so this
# should be removed soon...

#env.Append(CPPPATH = '/usr/include/netcdf')
#env.Append(LIBS = ['pq', 'boost_date_time'])

# To get netcdf libraries on the link command line with static linking,
# they need to be added to the end of the link command.  Adding them to
# LINKFLAGS does not work, because LINKFLAGS is expanded on the command
# line *before* LIBFLAGS.  There is no way to specify the libraries as
# static in LIBS, since members of LIBS are always expanded to -l<lib>.
# The only way to avoid that would be to replace the _stripixes() function,
# and I don't want to go there.  I've been there, and it's not pretty.

#env['NETCDFLIBS'] = ['-lnetcdf_c++', '-lnetcdf', '-lhdf5_hl', '-lhdf5']
#env['LINKCOM'] = env['LINKCOM'] + " $NETCDFLIBS"

# The Configure context is just being used as a check here.  We don't want
# the checks to affect the special linking setup above by appending
# libraries to LIBS.  Thus we create the context on a copy of the
# environment, and we don't use the Finish()ed product.  All the Configure
# checks appeared to do before were add -lnetcdf_c++ and -lpq to the LIBS,
# but those had already been given on the command line anyway.  Really this
# could be removed, since if netcdf or pq aren't installed, then the build
# will still fail.  However it's left here in case someday someone wants to
# really make it work.

# conf = Configure(env.Clone())
#if not conf.CheckLibWithHeader('netcdf', 'netcdf.h', 'C'):
#    print 'netCDF must be installed!'
#    Exit(1)

#if not conf.CheckLibWithHeader('netcdf_c++', 'netcdf.hh', 'C++'):
#    print 'netCDF C++ must be installed!'
#    Exit(1)

#if not conf.CheckLibWithHeader('pq', 'libpq-fe.h', 'C'):
#    print 'PostgreSQL must be installed!'
#    Exit(1)

# As mentioned above, we need to ignore the alterations Configure
# makes to the environment.
# env = conf.Finish()

# If you rely on Configure to add libraries, you have to check for them in
# reverse order of their dependencies, ie, check for netcdf before
# netcdf_c++, otherwise netcdf_c++ cannot be linked.  However, when
# statically linking, that means the libraries need to be listed in LIBS in
# the reverse order they are checked by Configure.  Since at the moment
# Configure is not being used to add to LIBS, we don't need this.
# env['LIBS'].reverse()

# print env.Dump()

objects = env.StaticObject([
                       'Config.cc',
                       'AircraftTrackKML.cc',
                       'AircraftTrack.cc',
                       'acDatabase.cc',
                       'ncTrack.cc',
                       'osm.cc'])

actrack = env.Program(['acTrack2kml.cc'] + objects)
env.Default(actrack)

Alias('install', env.Install('$JLOCAL/bin', 'acTrack2kml'))


# Find aircraft production netcdf files to test against.
#
def FindAircraftData(filename):
    searchdirs = ['$DATA_DIR/HIPPO', '/scr/raf_data/HIPPO']
    for d in searchdirs:
        d = os.path.expandvars(d)
        path = os.path.join(d, filename)
        if os.path.exists(path):
            print("found %s in %s" % (filename, path))
            return path
    return None


# Generate KML from a netcdf file.
def NetcdfKML(target, source, env):
  ifile = str(env.File(source[0]))
  ofile = str(env.File(target[0]))
  jfile = str(env.File(target[1]))
  env.Execute("${ACTRACK2KML} %s %s %s" % (ifile, ofile, jfile))


def kml_emitter(source, target, env):
  ofile = str(env.File(target[0]))
  jfile = ofile + ".json"
  if ofile.endswith(".kml"):
      jfile = ofile[:-4] + ".json"
  if not env.has_key('ACTRACK2KML'):
      env['ACTRACK2KML'] = actrack[0].get_abspath()
  return (target + [jfile], source + [ env['ACTRACK2KML'] ])


env['BUILDERS']['NetcdfKML'] = Builder(action=NetcdfKML, emitter=kml_emitter)

ncpath = FindAircraftData('HIPPO-2rf06.nc')
if ncpath:
    ekml = 'HIPPO-2rf06.kml'
    ejson = 'HIPPO-2rf06.json'
    akml = 'HIPPO-2rf06-actual.kml'
    (akml, ajson) = env.NetcdfKML(akml, ncpath)
    env.Alias('xdiff', 
              env.Command("diff", [ekml, akml],
                          "diff --side-by-side --width=170 ${SOURCES}"))
    env.Alias('test', env.Command("diff1", [ekml, akml], "diff ${SOURCES}"))
    env.Alias('test', env.Command("diff2", [ejson, ajson], "diff ${SOURCES}"))

gtests = env.Program('gtests', ["test_track.cc"] + objects,
                     LIBS=env['LIBS'] + ['gtest_main', 'gtest'])

env.Alias('test', env.Command('gtest', gtests, gtests[0].abspath))

pg = env.PostgresTestDB()

# Generate KML output from a database SQL file.  The source is the SQL dump
# and the target is the real-time.kml file.
database_kml_builder = Builder(action=[
    pg.action_init,
    Mkdir("${TARGET.dir}"),
    "${ACTRACK2KML} -v --once -p ${AIRCRAFT} -f ${TARGET.dir}/..",
    pg.action_stop])

env.Append(BUILDERS = {'DatabaseKML':database_kml_builder})

def diff_files(target, source, env):
    diffs = None
    p1 = source[0].get_abspath()
    p2 = source[1].get_abspath()
    f1 = open(p1, "rb")
    f2 = open(p2, "rb")
    diff = difflib.unified_diff(f1.readlines(), f2.readlines())
    f1.close()
    f2.close()
    diffs = [line for line in diff]
    if diffs:
        print("".join(diffs))
        return str("Differences found between " + 
                   str(source[0]) + " and " + str(source[1]))
    return None

diff_builder = Builder(action=[diff_files])
env.Append(BUILDERS = {'Diff':diff_builder})

gvkml = env.DatabaseKML("GV-actual/GE/real-time.kml", "real-time-GV.sql",
                        AIRCRAFT='GV', ENV=pg.getEnvironment())

# Only the GV SQL data has points, so add it to the test alias.  The C-130
# comparison fails because no files are generated.
#
env.Alias('test', env.Diff('testgv-kml',
                           ["GV-expected/GE/real-time.kml",
                            "GV-actual/GE/real-time.kml"]))
#env.Alias('test', env.Diff('testgv-animated',
#                           ["GV-expected/GE/animated-track.kml",
#                            "GV-actual/GE/animated-track.kml"]))
env.Alias('test', env.Diff('testgv-position',
                           ["GV-expected/position.json",
                            "GV-actual/position.json"]))
env.DatabaseKML('C130-actual/GE/real-time.kml', 'real-time-C130.sql', 
                AIRCRAFT='C130', ENV=pg.getEnvironment())

# The DLR test just makes sure it terminates and exits successfully.
dlr = env.DatabaseKML('DLR-actual/GE/real-time.kml', 'real-time-DLR.sql', 
                      AIRCRAFT='DLR', ENV=pg.getEnvironment())
env.Alias('test', dlr)

def dumpdb(target, source, env):
    platform = env['AIRCRAFT']
    db = "real-time"
    if platform:
        db = db + "-" + platform
    pg.dump("eol-rt-data.fl-ext.ucar.edu", "ads", db, target[0].get_abspath())


def DumpSql(env, sqltarget, aircraft):
    if [ t for t in BUILD_TARGETS if str(t).endswith(sqltarget) ]:
        sql = env.Command(sqltarget, None, env.Action(dumpdb), 
                          AIRCRAFT=aircraft)
        env.AlwaysBuild(sql)


DumpSql(env, 'real-time-GV.sql', 'GV')
DumpSql(env, 'real-time-C130.sql', 'C130')
DumpSql(env, 'real-time-N42RF.sql', 'N42RF')
DumpSql(env, 'real-time-DLR.sql', 'DLR')

