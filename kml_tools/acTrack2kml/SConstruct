# -*- python -*-

import os
import sys

if not os.path.exists("site_scons"):
    print("Creating site_scons link and re-running.")
    os.symlink("../../caledit/site_scons", "site_scons")
    os.chdir(GetLaunchDir())
    os.execv(sys.argv[0], sys.argv[:])

env = Environment(tools=['default', 'netcdf', 'postgres_pq', 
                         'boost_date_time', 'postgres_testdb'])
env['JLOCAL'] = os.environ['JLOCAL']

env.Append(CXXFLAGS='-g -Werror -Wall')

# ------------------------------------------------------------------------
# All the talk beneath here about static linking appears to be obsolete,
# since near as I can tell the current system installation of acTrack2kml
# uses dynamic linking of netcdf and probably has for some time, so this
# should be removed soon...

#env.Append(CPPPATH = '/usr/include/netcdf')
#env.Append(LIBS = ['pq', 'boost_date_time'])

# To get netcdf libraries on the link command line with static linking,
# they need to be added to the end of the link command.  Adding them to
# LINKFLAGS does not work, because LINKFLAGS is expanded on the command
# line *before* LIBFLAGS.  There is no way to specify the libraries as
# static in LIBS, since members of LIBS are always expanded to -l<lib>.
# The only way to avoid that would be to replace the _stripixes() function,
# and I don't want to go there.  I've been there, and it's not pretty.

#env['NETCDFLIBS'] = ['-lnetcdf_c++', '-lnetcdf', '-lhdf5_hl', '-lhdf5']
#env['LINKCOM'] = env['LINKCOM'] + " $NETCDFLIBS"

# The Configure context is just being used as a check here.  We don't want
# the checks to affect the special linking setup above by appending
# libraries to LIBS.  Thus we create the context on a copy of the
# environment, and we don't use the Finish()ed product.  All the Configure
# checks appeared to do before were add -lnetcdf_c++ and -lpq to the LIBS,
# but those had already been given on the command line anyway.  Really this
# could be removed, since if netcdf or pq aren't installed, then the build
# will still fail.  However it's left here in case someday someone wants to
# really make it work.

# conf = Configure(env.Clone())
#if not conf.CheckLibWithHeader('netcdf', 'netcdf.h', 'C'):
#    print 'netCDF must be installed!'
#    Exit(1)

#if not conf.CheckLibWithHeader('netcdf_c++', 'netcdf.hh', 'C++'):
#    print 'netCDF C++ must be installed!'
#    Exit(1)

#if not conf.CheckLibWithHeader('pq', 'libpq-fe.h', 'C'):
#    print 'PostgreSQL must be installed!'
#    Exit(1)

# As mentioned above, we need to ignore the alterations Configure
# makes to the environment.
# env = conf.Finish()

# If you rely on Configure to add libraries, you have to check for them in
# reverse order of their dependencies, ie, check for netcdf before
# netcdf_c++, otherwise netcdf_c++ cannot be linked.  However, when
# statically linking, that means the libraries need to be listed in LIBS in
# the reverse order they are checked by Configure.  Since at the moment
# Configure is not being used to add to LIBS, we don't need this.
# env['LIBS'].reverse()

# print env.Dump()

actrack = env.Program(['acTrack2kml.cc', 'Config.cc',
                       'AircraftTrackKML.cc',
                       'AircraftTrack.cc',
                       'acDatabase.cc',
                       'ncTrack.cc',
                       'osm.cc'])
env.Default(actrack)

Alias('install', env.Install('$JLOCAL/bin', 'acTrack2kml'))


# Find aircraft production netcdf files to test against.
#
def FindAircraftData(filename):
    searchdirs = ['$DATA_DIR/HIPPO', '/scr/raf_data/HIPPO']
    for d in searchdirs:
        d = os.path.expandvars(d)
        path = os.path.join(d, filename)
        if os.path.exists(path):
            print("found %s in %s" % (filename, path))
            return path
    return None


def BatchKML(target, source, env):
  ifile = env.File(source[0]).get_abspath()
  ofile = env.File(target[0]).get_abspath()
  if os.path.exists(ofile):
    os.unlink(ofile)
  env.Execute("${ACTRACK2KML} %s %s" % (ifile, ofile))


def kml_emitter(source, target, env):
  if not env.has_key('ACTRACK2KML'):
      env['ACTRACK2KML'] = actrack[0].get_abspath()
  return (target, source + [ env['ACTRACK2KML'] ])


env['BUILDERS']['BatchKML'] = Builder(action=BatchKML, emitter=kml_emitter)

ncpath = FindAircraftData('HIPPO-2rf06.nc')
if ncpath:
    ekml = 'HIPPO-2rf06.kml'
    akml = 'HIPPO-2rf06-actual.kml'
    env.BatchKML(akml, ncpath)
    env.Alias('xdiff', 
              env.Command("diff", [ekml, akml],
                          "diff --side-by-side --width=170 ${SOURCES}"))
    env.Alias('test', 
              env.Command("diff", [ekml, akml],
                          "diff ${SOURCES}"))

# To create SQL dumps of databases:
#
# pg_dump -h eol-rt-data.fl-ext.ucar.edu -U ads real-time-GV > real-time-GV.sql
# pg_dump -h eol-rt-data.fl-ext.ucar.edu -U ads real-time-C130 > real-time-C130.sql
#
#


test_sources = Split("""
test_track.cc
""")

gtests = env.Program('gtests', test_sources, LIBS=['gtest_main', 'gtest'])

env.Alias('test', env.Command('xtest', gtests, gtests[0].abspath))

pg = env.PostgresTestDB()

def rundb(target, source, env):
    pg.init()
    pg.start()
    pg.setupAircraftDatabase(source[0].get_abspath())
    return 0

def stopdb(target, source, env):
    pg.stop()
    return 0


compare_kml_builder = Builder(action=[
    rundb,
    Mkdir("${AIRCRAFT}-actual"),
    Mkdir("${AIRCRAFT}-actual/GE"),
    "${ACTRACK2KML} --once -p ${AIRCRAFT} -f ${SOURCE.dir}/${AIRCRAFT}-actual",
    Mkdir("${AIRCRAFT}-expected"),
    Mkdir("${AIRCRAFT}-expected/GE"),
    "/opt/local/raf/bin/acTrack2kml --once -p ${AIRCRAFT} -f ${SOURCE.dir}/${AIRCRAFT}-expected",
    stopdb,
    "diff ${AIRCRAFT}-expected/GE/real-time.kml ${AIRCRAFT}-actual/GE/real-time.kml"])

env.Append(BUILDERS = {'CompareKML':compare_kml_builder})

# Only the GV SQL data has points, so add it to the test alias.  The C-130
# comparison fails because no files are generated.
#
env.Alias('test',
          env.CompareKML('testgv', 'real-time-GV.sql', AIRCRAFT='GV',
                         ENV=pg.getEnvironment()))
env.CompareKML('testc130', 'real-time-C130.sql', AIRCRAFT='C130',
               ENV=pg.getEnvironment())

def dumpdb(target, source, env):
    platform = env['AIRCRAFT']
    db = "real-time"
    if platform:
        db = db + "-" + platform
    pg.dump("eol-rt-data.fl-ext.ucar.edu", "ads", db, target[0].get_abspath())

env.Command('real-time-GV.sql', None, env.Action(dumpdb), AIRCRAFT='GV')
env.Command('real-time-C130.sql', None, env.Action(dumpdb), AIRCRAFT='C130')

